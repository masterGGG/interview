# 7层协议各是那些？
应用层 http\ftp
表示层 
会话层
网络层 TCP\UDP
传输层 IP/ICMP
数据链路层 ARP
物理层

# 2. 三次握手：
1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入`SYN_SENT`状态，等待Server确认。
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入`SYN_RCVD`状态。
3. Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入`ESTABLISHED`状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
## 2.1 为什么TCP连接的时候是3次？2次不可以吗？
* > 为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤
* > 如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认
## 半连接状态？
服务端收到客户端发起的SYN请求后，内核会把该连接存储到半连接队列，并向客户端响应SYN+ACK，接着客户端会返回ACK，服务端收到第三次握手的ACK后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到accept队列，等待进程调用accept函数时把连接取出来。
* 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态。
* 半连接队列：在三次握手协议中，服务器维护一个半连接队列，存放半连接。该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的ACK确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。
# 3. 四次挥手：
由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。
1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入`FIN_WAIT_1`状态，此时客户端依然可以接收服务器发送来的数据。
2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入`CLOSE_WAIT`状态。客户端收到后进入`FIN_WAIT_2`状态。
3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入`LAST_ACK`状态，等待客户端的确认
4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入`TIME_WAIT`状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连

## close_wait和time_wait的区别？
`TIME_WAIT`是主动关闭方持有的最后状态，主动关闭方等待2MSL时间，确保最后一个ACK不会丢失。<span id="为什么需要TIME_WAIT状态"></span>假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入TIME_WAIT状态，因为client可能面临重发最终ACK的情形。
`CLOSE_WAIT`是被动关闭方接收到对方FIN请求之后形成的状态。但如果服务器端不执行close()，TCP状态就不能由`CLOSE_WAIT`迁移到`LAST_ACK`，系统中会存在很多处于CLOSE_WAIT状态的连接。
* > <span id="为什么TIME_WAIT状态需要保持2MSL这么长的时间"></span>主要是为了保证后续相同连接元组不会被前一次连接残留报文干扰。在2MSL时间后，前一次连接的报文要么相应完毕、要么过期失效。
* > <span id="TIME_WAIT 和CLOSE_WAIT状态socket过多"></span>
>  > 1. 服务器存在大量`CLOSE_WAIT`状态的socket，主要是由于服务器没有及时调用close方法切换状态，出现这种情况一般是因为服务器忙于socket读写。解决方案是使用完连接及时调用close方法、socket读控制，读到0字节立即close、检查错误值，不是EAGAIN就立即close连接。也可以设置TCP的keep_alive_time时间。
>  > 2. 服务器存在大量`TIME_WAIT`状态的socket，一般是由于高并发短连接的情况，导致大量连接处于`TIME_WAIT`状态。解决方案是打开内核的TIMEWAIT重用和快速回收配置。

## 3.1 为什么TCP连接的时候是3次，关闭的时候却是4次？
连接时不带数据传输，因此服务端SYN和ACK报文可以组合发送，关闭时需要等待双方数据传输完毕才能断开连接，所以需要4次。

## 3.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，若到保活时间还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

# TCP与UDP的区别，以及使用场景。
>  1. TCP面向连接;UDP是无连接的。
>  2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 
>  3. TCP面向字节流服务;UDP是面向报文的，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
>  4. TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
>  5. TCP首部开销20字节;UDP的首部开销只有8个字节 
>  6. TCP是全双工的可靠信道，UDP则是不可靠信道

**TCP头部组成(20字节)**
16位`源端口`和16位`目的端口`。
32位`序列号`：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。
32位`确认号`：用来响应TCP报文段，给收到的TCP报文段的序号加1，三握时还要携带自己的序号。
4位`头部长度`：标识该TCP头部有多少个4字节，共表示最长15*4=60字节。同IP头部。
6位`保留`。6位`标志`。URG（紧急指针是否有效）ACK（表示确认号是否有效）PSH（提示接收端应用程序应该立即从TCP接收缓冲区读走数据）RST（表示要求对方重新建立连接）SYN（表示请求建立一个连接）FIN（表示通知对方本端要关闭连接）
16位`窗口大小`：TCP流量控制的一个手段，用来告诉对端TCP缓冲区还能容纳多少字节。
16位`校验和`：由发送端填充，接收端对报文段执行CRC算法以检验TCP报文段在传输中是否损坏。
16位`紧急指针`：一个正的偏移量，它和序号段的值相加表示最后一个紧急数据的下一字节的序号。
**UDP头部组成（8字节）**
16位`源端口`
16位`目的端口`
16位整个数据报（UDP的首部+UDP数据）的`最大长度`
16位`检验和`

**TCP应用场景**：要求可靠传输的服务
**UDP应用场景**
>  1.面向数据报方式
>  2.网络数据大多为短消息 
>  3.拥有大量Client
>  4.对实时性要求较高、允许一定丢包的服务

# keepalive
链接建立之后，如果应用层或者上层协议一直不发送数据，或者是相隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方在线，到底是掉线，还是确实没有数据传输，链接还需不需要保持，这种情况在tcp协议设计中是需要考虑的。
tcp协议通过自动发送数据为空的探测报文给对方，如果对方回应，说明在线，链接可以继续保持，如果对方没有报文返回，并且重试多次之后，则认为链接丢失，没有必要保持链接，释放资源。
```
//开启keepalive
SO_KEEPALIVE
//设置每多少秒发送一次心跳包
TCP_KEEPIDLE   
//对端没有回应心跳包后，每隔多少秒发送一次心跳包  
TCP_KEEPINTVL 
//关闭一个非活跃链接之前的最大重试次数
TCP_KEEPCNT
```

# TCP_NODELAY
    Nagle算法比较适用于发送方发送大批量的小数据，并且接收方作出及时回应的场合，这样可以降低包的传输个数。
打开TCP_NODELAY:禁用nagle算法
    会增加小包的数量，但是可以保证响应速度。适合低延迟的系统。
禁用TCP_NODELAY：打开nagle算法
    增加通信的延时，增加带宽利用率。比较适合在容忍高延迟、数据量小、低带宽的通信场景。

# 滑动窗口
接收端可以根据自己的状况通告窗口大小，从而控制发送端的发送量，进行流量控制。

# 拥塞控制
发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。
**慢开始**算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段
**拥塞避免**，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。
**快重传和快恢复**：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期


HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷
HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的
QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议
# HTTP
**URL统一资源定位符**：<协议>://<域名>:<端口>/<路径>
HTTP超文本传输​​协议是位于 TCP/IP 体系结构中的应用层协议，基于TCP实现。
HTTP请求和回应的格式除了数据部分，每次通信都必须包括头信息（HTTP header），包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。
GET、POST
* HTTP缺点：安全不足和性能不高。
1. cs短链接、IO无法复用
2. 高延迟 — 队头阻塞
3. 明文传输 
4. 不支持服务端推送

# HTTPS
HTTP+SSL协议。
对称加密、非对称加密

# HTTP2
基于google的改进版协议SPDY，专注于性能，最大目标是用户和网站通信只用一个连接。
特点：
* > 二进制分帧
* > 多路复用
劣势：
1. TCP 以及 TCP+TLS 建立连接的延时
2. TCP 的队头阻塞并没有彻底解决
# HTTP3/QUIC
是google基于UDP开发的传输层协议
**主要特点**：
1. 改进的拥塞控制、可靠传输
2. 快速握手
3. 集成了 TLS 1.3 加密
4. 多路复用