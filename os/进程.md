[toc]

# 1. <span id="1">什么是进程？</span>
在早期面向程序设计计算机结构中，`进程`是基本执行实体，操作系统以进程为单位进行文件描述符、IO设备、内存等资源分配，并沿用至今。现在进程是程序的运行实例，是`操作系统资源调度和分配的最小单位`。
> [后续提问：什么是线程？](#2)

# 2. <span id="2">什么是线程？</span>
随着系统硬件的发展，内存等系统资源已经不是程序的瓶颈，线程被发明出来提升进程并发能力，线程是进程中的一段执行序列，或者说子任务，是`CPU执行调度和分派的基本单位`。
> [后续提问：进程与线程的区别是什么？](#3)

# 3. <span id="3">进程与线程的区别是什么？</span>
从**从属关系**上来说，进程是线程的容器，线程从属于进程。操作系统以进程为基本单位来进行文件描述符、内存、IO设备等内核资源的分配调度。而在CPU调度时，则是以线程为单位执行调度和分派的。
从**系统开销**上来说，进程由程序、数据和PCB三个部分组成，进程的切换需要将当前进程上下文环境（当前进程CPU寄存器中的数据）保存到进程的私有堆栈中，同时将要切换的进程上下文信息从进程私有堆栈中恢复到CPU的寄存器中，将代运行程序的断点送入PC。相对而言，进程切换的开销远远大于线程切换。当然这里说得线程切换指的是进程内部多个线程的切换，因为同进程内的多个线程共享进程的内存空间，文件描述符、IO设备等资源，在进行切换时，只需要保存少量线程相关的信息，比如线程私有栈、TCB、寄存器等信息就行了。至于跨进程的线程切换其实质就跟进程切换一致，就不详细阐述了。
从**数据共享**上来说，进程间地址空间相对独立，数据共享需要IPC辅助手段支持，通信同步复杂。而进程内的线程由于共享进程的内存空间，数据共享简单，但需要同步和互斥等手段保证一致性。
从**健壮性**上来说，进程间互不影响，健壮性比较高，在需要热重启，热加载等功能时，可以使用多进程服务。同一个进程中的某一个线程挂掉会导致整个进程挂掉，健壮性不如多进程。
从**扩展性**上来说，线程支持多核部署，进程不仅可以支持多核部署，还可以多机部署。

# 多进程以及多线程的区别？
多进程以及多线程编程都是为了提升系统的并发能力。
1. 多进程编程比较简单，健壮性好，但是由于进程间的地址空间不一样，需要额外的手段来提供信息同步。
多线程共享进程的地址空间，通信以及同步相对多进程比较容易，但是编程调试相对复杂。
2. 多线程编程需要保证函数线程安全性，编程调试相对复杂。
## 多进程以及多线程的优劣势以及应用场景
|维度|多进程|多线程|
|---|---|---|
|数据共享，通信|需要通过IPC进行进程间共享、通信，同步逻辑简单|共享地址空间，数据共享简单，同步需要保证线程安全，编码复杂|
|内存|进程拥有各自的地址空间，相同规模下，消耗资源多|线程共享地址空间，消耗内存资源少|
|CPU|进程创建切换开销大|线程创建切换的开销小|
|健壮性|进程互相独立，健壮性高|一个线程挂掉将导致整个服务挂掉，健壮性低|
|分布式|多核多机分布|多核分布|

|应用场景|多进程|多线程|
|---|---|---|
|计算密集型服务（图像、算法）|切换开销大，不适用|适用|
|分布式场景，鲁棒性要求高|适用|X|
|需要进行大数据共享或者频繁通信|X|适用|

# 进程通信
进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

# 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞
1）创建状态：进程正在被创建
2）就绪状态：进程被加入到就绪队列中等待CPU调度运行
3）执行状态：进程正在被运行
4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。
5）终止状态：进程运行完毕

# 线程同步
**条件变量**条件变量是用来等待某个条件，一般和互斥锁配合使。主要用于生产者消费者模式中，显著降低生产者与消费者、消费者与消费者之间的锁竞争。相比于互斥量，条件变量能够减少线程之间的竞争，只有在达到某个状态的情况下，才唤醒一个或多个阻塞的线程去竞争锁，进行相应处理。
```cpp
//c++11中条件变量的使用
//为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex，并且管理这个锁 只能是 std::unique_lock<std::mutex> RAII模板类。
#include <thread>                // std::thread
#include <mutex>                // std::mutex, std::unique_lock
#include <condition_variable>    // std::condition_variable
std::mutex mutex_;
std::condition_variable cond_;
bool ready_ = false;
void consume() {
  std::unique_lock<std::mutex> lock_(mutex_);
#if 1
  cond_.wait(lock_, ready);
#else
  while (!ready) {
    cond_.wait(lock_);
  }
#endif
  //consuming
}
void produce() {
  std::unique_lock<std::mutex> lock_(mutex);
  //prodecing
  ready_ = true;
  cond_.notify_one();
  cond_.notify_all();
}
```
**互斥量**Synchronized/Lock：采用互斥对象机制`std::mutex`，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
```cpp
std::mutex mutex_;
mutex_.lock();
mutex_.trylock();
mutex_.unlock();

std::unique_lock<std::mutex> lock_(mutex_);
std::lock_guard<std::mutex> guard_(mutex);
```
**信号量**Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
c++中没有实现信号量，可以通过互斥量以及条件变量组合的方式实现信号量。
信号量是一个整数 count，提供两个原子(atom，不可分割)操作：P 操作和 V 操作，或是说 wait 和 signal 操作。
P操作 (wait操作)：count 减1；如果 count < 0 那么挂起执行线程；
V操作 (signal操作)：count 加1；如果 count <= 0 那么唤醒一个执行线程；
```cpp
std::mutex mutex_;
std::condition_variable cond_;
int count_;
void wait() {
  std::unique_lock<std::mutex> lock_(mutex_);
  count_--;
  cond_.wait(lock_, count_ >= 0);
}
void signal() {
  std::unique_lock<std::mutex> lock_(mutex_);
  if (++count_ <= 0) {
    cond_.notify_one();
  }
}
```
**事件(信号)**，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

# 线程需要保存哪些上下文
参考回答：
线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：
SP:堆栈指针，指向当前栈的栈顶地址
PC:程序计数器，存储下一条将要执行的指令
EAX:累加寄存器，用于加法乘法的缺省寄存器

# 死锁发生的条件以及如何解决死锁
死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：
**互斥条件**
**请求和保持条件**
**不可剥夺条件**
**循环等待条件**
解决死锁的方法即破坏上述四个条件之一，主要方法如下：
资源一次性分配，从而剥夺请求和保持条件
可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

# 线程与携程