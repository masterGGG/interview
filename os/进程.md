[toc]

# 1. <span id="1">什么是进程？</span>
进程是程序的运行实例，拥有独立的地址空间，是`操作系统资源调度和分配的最小单位`。
> [后续提问：什么是线程？](#2)

# 2. <span id="2">什么是线程？</span>
线程是进程中的一段执行序列，或者说子任务，是`CPU执行调度和分派的基本单位`。
> [后续提问：进程与线程的区别是什么？](#3)

# 3. <span id="2">进程与线程的区别是什么？</span>
进程拥有独立的地址空间
# 进程与线程的概念
* `进程`是对运行时程序的封装，是系统进行**资源调度和分配的的基本单位**，实现了操作系统的并发；
* `线程`是进程的子任务，是**CPU调度和分派的基本单位**，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的**最小执行和调度单位**。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

# 进程线程有什么区别
```
进程是操作系统进行资源分配的最小单位，而线程时CPU调度的最小单元。
同一个进程多线程之间共享地址空间，通信简单，同步复杂。线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。
```
而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。
1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
2. 进程在执行过程中拥有独立的内存地址空间，而进程内的多个线程共享进程的内存地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3. **进程是资源分配的最小单位，线程是CPU调度的最小单位**
4. 系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统进行进程切换时所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
5. 通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
6. 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
7. 进程间不会相互影响，同一个进程中一个线程挂掉将导致整个进程挂掉
8. 进程适应于多核、多机分布；线程适用于多核

# 多进程以及多线程的区别？
多进程以及多线程编程都是为了提升系统的并发能力。
1. 多进程编程比较简单，健壮性好，但是由于进程间的地址空间不一样，需要额外的手段来提供信息同步。
多线程共享进程的地址空间，信息通信以及同步相对多进程比较容易，但是编程调试相对复杂。
2. 多线程编程需要保证函数线程安全性，编程调试相对复杂。
## 多进程以及多线程的优劣势以及应用场景
|维度|多进程|多线程|
|---|---|---|
|数据共享，通信|需要通过IPC进行进程间共享、通信，同步逻辑简单|共享地址空间，数据共享简单，同步需要保证线程安全，编码复杂|
|内存|进程拥有各自的地址空间，相同规模下，消耗资源多|线程共享地址空间，消耗内存资源少|
|CPU|进程创建切换开销大|线程创建切换的开销小|
|健壮性|进程互相独立，健壮性高|一个线程挂掉将导致整个服务挂掉，健壮性低|
|分布式|多核多机分布|多核分布|

|应用场景|多进程|多线程|
|---|---|---|
|计算密集型服务（图像、算法）|切换开销大，不适用|适用|
|分布式场景，鲁棒性要求高|适用|X|
|需要进行大数据共享或者频繁通信|X|适用|

# 进程通信
进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

# 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞
1）创建状态：进程正在被创建
2）就绪状态：进程被加入到就绪队列中等待CPU调度运行
3）执行状态：进程正在被运行
4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。
5）终止状态：进程运行完毕

# 线程同步
**条件变量**条件变量是用来等待某个条件，一般和互斥锁配合使。主要用于生产者消费者模式中，显著降低生产者与消费者、消费者与消费者之间的锁竞争。相比于互斥量，条件变量能够减少线程之间的竞争，只有在达到某个状态的情况下，才唤醒一个或多个阻塞的线程去竞争锁，进行相应处理。
```cpp
//c++11中条件变量的使用
//为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex，并且管理这个锁 只能是 std::unique_lock<std::mutex> RAII模板类。
#include <thread>                // std::thread
#include <mutex>                // std::mutex, std::unique_lock
#include <condition_variable>    // std::condition_variable
std::mutex mutex_;
std::condition_variable cond_;
bool ready_ = false;
void consume() {
  std::unique_lock<std::mutex> lock_(mutex_);
#if 1
  cond_.wait(lock_, ready);
#else
  while (!ready) {
    cond_.wait(lock_);
  }
#endif
  //consuming
}
void produce() {
  std::unique_lock<std::mutex> lock_(mutex);
  //prodecing
  ready_ = true;
  cond_.notify_one();
  cond_.notify_all();
}
```
**互斥量**Synchronized/Lock：采用互斥对象机制`std::mutex`，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
```cpp
std::mutex mutex_;
mutex_.lock();
mutex_.trylock();
mutex_.unlock();

std::unique_lock<std::mutex> lock_(mutex_);
std::lock_guard<std::mutex> guard_(mutex);
```
**信号量**Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
c++中没有实现信号量，可以通过互斥量以及条件变量组合的方式实现信号量。
信号量是一个整数 count，提供两个原子(atom，不可分割)操作：P 操作和 V 操作，或是说 wait 和 signal 操作。
P操作 (wait操作)：count 减1；如果 count < 0 那么挂起执行线程；
V操作 (signal操作)：count 加1；如果 count <= 0 那么唤醒一个执行线程；
```cpp
std::mutex mutex_;
std::condition_variable cond_;
int count_;
void wait() {
  std::unique_lock<std::mutex> lock_(mutex_);
  count_--;
  cond_.wait(lock_, count_ >= 0);
}
void signal() {
  std::unique_lock<std::mutex> lock_(mutex_);
  if (++count_ <= 0) {
    cond_.notify_one();
  }
}
```
**事件(信号)**，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

# 线程需要保存哪些上下文
参考回答：
线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：
SP:堆栈指针，指向当前栈的栈顶地址
PC:程序计数器，存储下一条将要执行的指令
EAX:累加寄存器，用于加法乘法的缺省寄存器

# 死锁发生的条件以及如何解决死锁
死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：
**互斥条件**
**请求和保持条件**
**不可剥夺条件**
**循环等待条件**
解决死锁的方法即破坏上述四个条件之一，主要方法如下：
资源一次性分配，从而剥夺请求和保持条件
可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

# 线程与携程