[toc]

# 进程与线程的区别
> 从概念上来说，<span id="什么是进程"></span>进程是**资源分配**的基本单位，<span id="什么是线程"></span>线程是操作系统**调度**的最小单位。

> <span id="进程拥有的资源"></span>操作系统创建进程时会为他分配进程控制器、虚拟地址空间等资源。线程从属于进程，共享进程虚拟地址空间，<span id="线程拥有的资源"></span>线程自己独有是`线程控制器`、`线程栈`。
> 在linux平台中，线程是轻量级的进程，分为用户态线程和内核态线程。根据这两种线程的映射关系，衍生除了3种线程模型。
> 分别是用户级线程模型、内核级线程模型以及两级线程模型。在linux采用的内核级线程模型中，`一个用户线程对应一个内核线程`。这种模型兼容了内核线程的优势，用户态线程互不影响，可以充分利用多核系统的优势，实现了真正意义上的并行处理。缺点也同样明显，线程创建、销毁、切换的开销更大，影响用户线程性能；许多操作系统对内核线程数量有限制，从而限制用户线程的数量。

> 1. 进程间地址空间互相独立，多进程编程简单、隔离性好、容错率高；而多线程中一个线程异常会导致进程的异常，容错率低。
> 2. 进程间数据共享需要通信，比如说管道、共享内存、消息队列、信号、socket等；多线程共享进程的地址空间，数据共享和通信方便。
> 3. 进程创建、切换和销毁的开销比线程大很多，占用内存多。

> 传统的`协程`可以理解成用户态线程，许多语言实现的协程库都是基于用户级线程模型设计的，在这种模型里，多个用户线程对应一个内核线程，用户线程的调度由应用程序控制，内核只能感知到进程，对其中的用户线程无感知。由于线程调度是在用户态完成的，不涉及CPU状态切换，对系统的消耗要小很多。协程的优势是没有数量的限制；用户态调度，执行效率更高；也不需要加锁，因为同一个进程中的协程是串行执行的，不存在共享变量的竞争。传统协程的劣势是不能实现真正意义上的并发，如果某一个协程阻塞住，会导致整个进程都阻塞住。

# 为什么线程异常会导致进程异常
一般线程异常会发出错误信号，如果进程内没有注册异常信号处理函数，操作系统默认信号处理函数会终止进程。
exit(1)；->_exit()->。。。。。。
# 进程退出
进程结束分为两个阶段，进程退出和进程销毁。
> 进程退出阶段主要是释放进程占用的资源，使进程进入僵死状态。包括检查文件打开情况，将文件缓冲区的内容写回文件，释放打开的文件描述符，释放进程占用的内存和页表。释放用户空间信号量，锁等资源。
> 进程销毁阶段主要是通过父进程销毁子进程的进程描述符，释放内核栈内存。

## 僵尸进程和孤儿进程
如果是子进程先退出，父进程会接收子进程的退出信号，便于管理。但如果父进程忽略子进程的退出信号，子进程就会成为僵尸进程，直到系统重启。
如果是父进程先退出，不会通知子进程，这个时候子进程就会成为孤儿进程，最终被init进程收养。

# 4. <span id="4">进程切换为什么消耗更大？</span>
进程上下文切换主要可以分为两个部分：
一是切换新进程的页表，使用新进程的虚拟内存。
二是切换内核栈，加载新进程（的PCB、PC、寄存器、文件描述符集合等）。
进程切换开销比线程大的主要因素是第一部分页表的切换耗时，而在同一个进程中的线程因为共享内存地址空间、文件描述符集合，不需要进行页表的切换。页表查找本身比较耗时，因此操作系统会用TLB来缓存页表，进程切换会导致TLB失效，缓存命中率下降，同时需要重新查找页表，进程的切换耗时就会增高。
> [后续提问：虚拟内存？](#4)
> [后续提问：缺页置换算法？](#4)OPT、FIFO、LRU
> [后续提问：进程切换为什么消耗更大？](#4)
> [后续提问：线程需要保存哪些上下文？](#5)

# <span id="5">线程需要保存哪些上下文</span>
参考回答：
线程在切换的过程中需要保存当前线程TCB、程序计数器、线程栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：
SP:堆栈指针，指向当前栈的栈顶地址
PC:程序计数器，存储下一条将要执行的指令
EAX:累加寄存器，用于加法乘法的缺省寄存器

# 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞
1）创建状态：进程正在被创建
2）就绪状态：进程被加入到就绪队列中等待CPU调度运行
3）执行状态：进程正在被运行
4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。
5）终止状态：进程运行完毕

# 线程同步
**条件变量**条件变量是用来等待某个条件，一般和互斥锁配合使。主要用于生产者消费者模式中，显著降低生产者与消费者、消费者与消费者之间的锁竞争。相比于互斥量，条件变量能够减少线程之间的竞争，只有在达到某个状态的情况下，才唤醒一个或多个阻塞的线程去竞争锁，进行相应处理。
```cpp
//c++11中条件变量的使用
//为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex，并且管理这个锁 只能是 std::unique_lock<std::mutex> RAII模板类。
#include <thread>                // std::thread
#include <mutex>                // std::mutex, std::unique_lock
#include <condition_variable>    // std::condition_variable
std::mutex mutex_;
std::condition_variable cond_;
bool ready_ = false;
void consume() {
  std::unique_lock<std::mutex> lock_(mutex_);
#if 1
  cond_.wait(lock_, ready);
#else
  while (!ready) {
    cond_.wait(lock_);
  }
#endif
  //consuming
}
void produce() {
  std::unique_lock<std::mutex> lock_(mutex);
  //prodecing
  ready_ = true;
  cond_.notify_one();
  cond_.notify_all();
}
```
**互斥量**Synchronized/Lock：采用互斥对象机制`std::mutex`，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
```cpp
std::mutex mutex_;
mutex_.lock();
mutex_.trylock();
mutex_.unlock();

std::unique_lock<std::mutex> lock_(mutex_);
std::lock_guard<std::mutex> guard_(mutex);
```
**信号量**Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
c++中没有实现信号量，可以通过互斥量以及条件变量组合的方式实现信号量。
信号量是一个整数 count，提供两个原子(atom，不可分割)操作：P 操作和 V 操作，或是说 wait 和 signal 操作。
P操作 (wait操作)：count 减1；如果 count < 0 那么挂起执行线程；
V操作 (signal操作)：count 加1；如果 count <= 0 那么唤醒一个执行线程；
```cpp
std::mutex mutex_;
std::condition_variable cond_;
int count_;
void wait() {
  std::unique_lock<std::mutex> lock_(mutex_);
  count_--;
  cond_.wait(lock_, count_ >= 0);
}
void signal() {
  std::unique_lock<std::mutex> lock_(mutex_);
  if (++count_ <= 0) {
    cond_.notify_one();
  }
}
```
**事件(信号)**，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

# 死锁发生的条件以及如何解决死锁
死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：
**互斥条件**
**请求和保持条件**
**不可剥夺条件**
**循环等待条件**
解决死锁的方法即破坏上述四个条件之一，主要方法如下：
资源一次性分配，从而剥夺请求和保持条件
可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件
