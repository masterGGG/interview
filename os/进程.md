[toc]

# 进程与线程的区别
定义：进程是操作系统资源分配的基本单位，线程是操作调度的基本单位。
进程对于操作系统来说，操作系统会把进程当作分配资源的--->,这些资源包括.....-->，线程是衍生与进程的，它共享进程的......，自己独有....，

在linux平台下，进程是.....，线程是....，它是....线程模型，KSE是`操作系统内核调度器调度的对象实体`，某一些地方也把他称作内核级线程，这就是我们常说的`线程是操作系统调度和分派的最小单位`。与KSE相对的是`用户态线程`，用户态线程运行在用户态，切换和调度由应用程序封装的线程库控制，对于操作系统不可见。
常用线程模型.....,linux使用这么线程模型优势....，劣势
多进程环境：
  优势
  劣势
多线程环境
  优势
  劣势
协程：
  1.定义：
  2.演进过程，线程模型--->协程-->应用场景
  3.实例：有栈、无栈，你看过的，优势在哪里、劣势，golang、libco，ucontext、异步io_using


从概念上来说，`进程是操作系统资源分配和调度的基本单位，线程是操作系统调度和分派的最小单位`。
进程是一个拥有资源和执行任务的集合，操作系统会以进程为单位进行资源分配，这些资源包括PCB、IO资源、内存、文件、寄存器等。线程衍生于进程，可以说是进程中的执行任务，它几乎不拥有系统资源。同一个进程中的线程共享进程IO、内存、文件等所有系统资源，线程自己独有是`TCB`、`程序计数器`、`栈和寄存器`。
在linux平台下，进程是程序运行的实体，线程是进程的一条执行路径。linux采用内核级线程模型进行线程的管理，应用程序创建的线程都由操作系统管理和调度。c++11的std::thread就是基于内核级线程模型实现的线程库。关于线程模型，一共有三种，分别是用户级线程模型、内核级线程模型以及两级线程模型，三者的主要区别是用户态线程和内核态线程的对应关系。linux采用的内核级线程模型中，一个用户线程对应一个内核线程。这种模型的优势是实现简单，用户态线程互不影响，可以充分利用多核系统的优势，实现了真正意义上的并行处理。缺点也同样明显，线程创建、销毁、切换的开销更大，影响性能。
`多进程`是在操作系统中同时跑多个进程，提升并发能力。他的优势是编程简单，容错率高，隔离性好。缺点是占用多份系统资源，开销更大，而且进程内存地址相对独立，需要额外的IPC手段进行通信共享。一些需要扩展到多台机器分布的服务、单进程收包成为瓶颈的服务以及CPU密集型服务，大多采用多进程模型设计。
`多线程`的核心优势在于数据共享，避免不必要的内存占用；线程的创建、切换、销毁的开销更小。劣势是需要保证函数安全，编程调试复杂，一个线程的异常会导致进程的异常。IO密集型服务，单机多核分布的服务，有优先级的任务调度，适合采用多线程模型。

# 1. <span id="1">什么是进程？</span>
在早期面向程序设计计算机结构中，`进程`是基本执行实体，操作系统以进程为单位进行文件描述符、IO设备、内存等资源分配，并沿用至今。现在进程是程序的运行实例，是`操作系统资源调度和分配的最小单位`。
> [后续提问：什么是线程？](#2)

# 2. <span id="2">什么是线程？</span>
随着系统硬件的发展，内存等系统资源已经不是程序的瓶颈，线程被发明出来提升进程并发能力，线程是进程中的一段执行序列，或者说子任务，是`CPU执行调度和分派的基本单位`。
> [后续提问：进程与线程的区别是什么？](#3)

# 3. <span id="3">进程与线程的区别是什么？</span>
从**从属关系**上来说，进程是线程的容器，线程从属于进程。操作系统以进程为基本单位来进行文件描述符、内存、IO设备等内核资源的分配调度。而在CPU调度时，则是以线程为单位执行调度和分派的。
从**系统开销**上来说，进程是操作系统资源分配的最小单位，需要管理各自的虚拟内存、页表、文件描述符、寄存器、PC等资源，占用内存多。线程只包含线程私有栈、TCB、寄存器等资源，占用内存小。
从**数据共享**上来说，进程间地址空间相对独立，数据共享需要IPC辅助手段支持，通信同步复杂。而进程内的线程由于共享进程的内存空间，数据共享简单，但需要同步和互斥等手段保证一致性。
从**健壮性**上来说，进程间互不影响，健壮性比较高，在需要热重启，热加载等功能时，可以使用多进程服务。同一个进程中的某一个线程挂掉会导致整个进程挂掉，健壮性不如多进程。
////从**扩展性**上来说，线程支持多核部署，进程不仅可以支持多核部署，还可以多机部署。
> [后续提问：进程切换为什么消耗更大？](#4)

# 4. <span id="4">进程切换为什么消耗更大？</span>
进程上下文切换主要可以分为两个部分：
一是切换新进程的页表，使用新进程的虚拟内存。
二是切换内核栈，加载新进程（的PCB、PC、寄存器、文件描述符集合等）。
进程切换开销比线程大的主要因素是第一部分页表的切换耗时，而在同一个进程中的线程因为共享内存地址空间、文件描述符集合，不需要进行页表的切换。页表查找本身比较耗时，因此操作系统会用TLB来缓存页表，进程切换会导致TLB失效，缓存命中率下降，同时需要重新查找页表，进程的切换耗时就会增高。
> [后续提问：虚拟内存？](#4)
> [后续提问：缺页置换算法？](#4)OPT、FIFO、LRU
> [后续提问：进程切换为什么消耗更大？](#4)
> [后续提问：线程需要保存哪些上下文？](#5)

# <span id="5">线程需要保存哪些上下文</span>
参考回答：
线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：
SP:堆栈指针，指向当前栈的栈顶地址
PC:程序计数器，存储下一条将要执行的指令
EAX:累加寄存器，用于加法乘法的缺省寄存器

# 多进程以及多线程的区别？
多进程以及多线程编程都是为了提升系统的并发能力。
1. 多进程编程比较简单，健壮性好，但是由于进程间的地址空间不一样，需要额外的手段来提供信息同步。
多线程共享进程的地址空间，通信以及同步相对多进程比较容易，但是编程调试相对复杂。
2. 多线程编程需要保证函数线程安全性，编程调试相对复杂。
3. 线程支持多核部署，进程不仅可以支持多核部署，还可以多机部署。

## 多进程以及多线程的优劣势以及应用场景
|维度|多进程|多线程|
|---|---|---|
|数据共享，通信|需要通过IPC进行进程间共享、通信，同步逻辑简单|共享地址空间，数据共享简单，同步需要保证线程安全，编码复杂|
|内存|进程拥有各自的地址空间，相同规模下，消耗资源多|线程共享地址空间，消耗内存资源少|
|CPU|进程创建切换开销大|线程创建切换的开销小|
|健壮性|进程互相独立，健壮性高|一个线程挂掉将导致整个服务挂掉，健壮性低|
|分布式|多核多机分布|多核分布|

|应用场景|多进程|多线程|
|---|---|---|
|计算密集型服务（图像、算法）|切换开销大，不适用|适用|
|分布式场景，鲁棒性要求高|适用|X|
|需要进行大数据共享或者频繁通信|X|适用|

# 进程通信
进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

# 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞
1）创建状态：进程正在被创建
2）就绪状态：进程被加入到就绪队列中等待CPU调度运行
3）执行状态：进程正在被运行
4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。
5）终止状态：进程运行完毕

# 线程同步
**条件变量**条件变量是用来等待某个条件，一般和互斥锁配合使。主要用于生产者消费者模式中，显著降低生产者与消费者、消费者与消费者之间的锁竞争。相比于互斥量，条件变量能够减少线程之间的竞争，只有在达到某个状态的情况下，才唤醒一个或多个阻塞的线程去竞争锁，进行相应处理。
```cpp
//c++11中条件变量的使用
//为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex，并且管理这个锁 只能是 std::unique_lock<std::mutex> RAII模板类。
#include <thread>                // std::thread
#include <mutex>                // std::mutex, std::unique_lock
#include <condition_variable>    // std::condition_variable
std::mutex mutex_;
std::condition_variable cond_;
bool ready_ = false;
void consume() {
  std::unique_lock<std::mutex> lock_(mutex_);
#if 1
  cond_.wait(lock_, ready);
#else
  while (!ready) {
    cond_.wait(lock_);
  }
#endif
  //consuming
}
void produce() {
  std::unique_lock<std::mutex> lock_(mutex);
  //prodecing
  ready_ = true;
  cond_.notify_one();
  cond_.notify_all();
}
```
**互斥量**Synchronized/Lock：采用互斥对象机制`std::mutex`，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
```cpp
std::mutex mutex_;
mutex_.lock();
mutex_.trylock();
mutex_.unlock();

std::unique_lock<std::mutex> lock_(mutex_);
std::lock_guard<std::mutex> guard_(mutex);
```
**信号量**Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
c++中没有实现信号量，可以通过互斥量以及条件变量组合的方式实现信号量。
信号量是一个整数 count，提供两个原子(atom，不可分割)操作：P 操作和 V 操作，或是说 wait 和 signal 操作。
P操作 (wait操作)：count 减1；如果 count < 0 那么挂起执行线程；
V操作 (signal操作)：count 加1；如果 count <= 0 那么唤醒一个执行线程；
```cpp
std::mutex mutex_;
std::condition_variable cond_;
int count_;
void wait() {
  std::unique_lock<std::mutex> lock_(mutex_);
  count_--;
  cond_.wait(lock_, count_ >= 0);
}
void signal() {
  std::unique_lock<std::mutex> lock_(mutex_);
  if (++count_ <= 0) {
    cond_.notify_one();
  }
}
```
**事件(信号)**，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

# 死锁发生的条件以及如何解决死锁
死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：
**互斥条件**
**请求和保持条件**
**不可剥夺条件**
**循环等待条件**
解决死锁的方法即破坏上述四个条件之一，主要方法如下：
资源一次性分配，从而剥夺请求和保持条件
可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

# 线程与携程