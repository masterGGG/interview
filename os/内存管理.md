[toc]

# 请你介绍一下虚拟内存
虚拟内存是应用程序和物理内存之间的一个中间层，将计算机上有限的物理内存分配给多个程序使用，并做到隔离各个进程的地址空间。早期的操作系统直接分配一段连续的物理内存运行程序，执行程序占用的内存很大或很多，就会导致物理内存消耗殆尽，针对这种问题衍生出的一种用磁盘空间充当内存来使用的机制。到了现代计算机操作系统，为了提高内存利用率，能同时运行多个程序，操作系统采用虚拟内存机制来管理内存。
Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。虚拟地址空间的内部又被分为内核空间和用户空间两部分；我们的进程在用户态的时候，只能访问用户空间；只有进入内核态，才能访问内核空间；用户空间是每个进程私有的；内核空间是每个进程共享的；
通过内存映射MMU将虚拟内存地址映射到物理内存地址，对实际使用虚拟内存并分配的物理内存进行管理；
用户空间大致可以分为栈、内存映射区、堆、未初始化数据段、初始化数据段、代码段6个部分。
栈：保存局部变量、函数形参、自动变量。数据具有后进先出的特点；
内存映射区：mmap，共享库
堆：保存由malloc、ralloc、calloc分配空间的变量。
BSS段：保存未初始化或初始化为0的全局变量和静态局部变量。
数据段：保存初始化不为0的全局变量或者static修饰的变量。
代码段：保存代码、可执行代码、字符串字面值、只读变量；

# 好处
1. 扩大地址空间；
2. 资源隔离，内存保护
3. 当进程通信时，可采用虚存共享的方式实现。
4. 在内存中可以保留多个进程，提高系统并发能力
# 代价：
1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存
2.虚拟地址到物理地址的转换，增加了指令的执行时间。
3.页面置换需要磁盘I/O，这是很耗时的
4.如果一页中只有一部分数据，会浪费内存

# 概念
为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。
虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。
请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

# 操作系统如何管理虚拟内存和物理内存？
## 分段
## 分页

# 缺页中断
malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。
缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
1、保护CPU现场
2、分析中断原因
3、转入缺页中断处理程序进行处理
4、恢复CPU现场，继续执行
但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：
1、在指令执行期间产生和处理缺页中断信号
2、一条指令在执行期间，可能产生多次缺页中断
3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

# 置换算法
当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：
先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。
最不经常使用淘汰算法（Least Frequently Used）。LFU是淘汰一段时间内，使用次数最少的页面。

当前最常采用的就是LRU算法。

# 虚拟内存
## 1.虚拟存储的需求背景

随着软件的快速发展，需要运行的程序往往大到内存无法容纳，而且需要系统能够支持多个程序同时运行。为了有效管理物理内存，采用了分段、分页，也许在这个基础上可以达到更大更快的理想情况，但数据随着掉电会丢失，硬件还达不到。我们仍然希望将不经常访问的数据放在硬盘中，对硬件和OS要求很高。
针对系统内存不够的情况

1）早期，微软的Dos，内存仅仅640k，程序大-手动覆盖（overlay），把需要的指令和数据保存在内存中

2）程序多，自动交换基础（swapping），暂时不能执行的程序送到外存，代价大

3）以更小的页粒度单位在有限的内存中装入更多更大的程序，采用自动的虚拟存储技术
## 2.覆盖和交换
### 2.1覆盖技术
**背景**
    早期，DOS，硬件只有640kb的内存，软件几十k，大的上兆。Turbo Pascal的overlay系统单元支持程序员控制的覆盖技术
**目标**
    小内存中运行较大程序，常用于多道程序系统，与分区存储管理配合使用
**原理**
    按自身逻辑把程序分成几个功能上相对独立的模块，不会同时执行的模块可以共享同一块内存区域，按时间先后运行（分时）必要的代码和数据常驻内存，
    optional的不常用的在其余模块中实现，放外村，需要时释放内存，不存在调用关系的模块不必同时载入内存，可以相互覆盖，公用一个分区。
**缺点**

1）设计开销，程序员要划分模块和确定覆盖关系，编程复杂度增加

2）覆盖模块从外村装入内存，实际是以时间来换空间

### 2.2交换技术
**背景** 

unix 让os管理而不是程序员管理，以运行的程序为管理单位

**目标**：

多道程序在内存中时，让正在运行的程序或需要运行的程序有更多的内存资源。

**方法**：

可将暂时不能运行的程序送到外存以获得空闲内存空间，操作系统在内存管理单元MMU帮助下把一个进程的整个地址空间内容保存在外存中（换出 swap out）,而将外存中的某个进程的地址空间读入到内存中（换入swap in）。其大小为整个程序的地址空间（比较大，几十几百个页）。

**何时交换?**
硬盘操作很慢，一动系统就要等，所以当内存空间确实不够，或者有不够的危险时换出。

**交换区的大小？**
极端下是内存中只留一个程序，其余都在交换区。
必须够大以存放所有用户进程的所有内存映像的拷贝；

必须能对这些内存映像直接存储；
swap in重定位：再次换入的内存地址一定要在原来位置上吗？
不一定，可能已被占用，要正确寻址，需要动态地址映射，虚拟地址一样，物理地址不一样。

**覆盖和交换比较**
目的是一样的
覆盖发生在一个运行中的程序内部没有调用关系的模块之间，代价是程序员手动指定和划分逻辑覆盖结构；
交换是内存中程序与管理程序或OS之间发生的，以进程作为交换的单位，需要把进程的整个地址空间都换进换出，对程序员是透明的，开销相对较大。

## 3.局部性原理
局部性原理
    程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域
    1.时间局部性
        一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内
    2.空间局部性
        当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内
    3.分支局部性
        一条跳转指令的两次执行，很可能跳到相同的内存位置
局部性原理的意义
    从理论上来说，虚拟存储技术是能够实现的，而且可取得满意的效果

覆盖和交换都有缺点。   
为了实现虚存，要利用程序的局部性原理

程序在执行过程中的一个较短时期，所执行的指令的地址，指令的操作数地址都局限于一定区域：   
* 时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都在较短时间内
* 空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小的区域内。

**小空间、高效**   
原理表明理论上虚存可以实现。程序只有一小部分在内存上，大部分在硬盘上，os在MMU帮助下完成。

**虚存机制**   
    在分页、分段内存管理的硬件支持下，在装入程序时，只把当前需要执行的部分页或段装入内存，就可以开始执行；   
    当执行到指令或数据不在内存上时（缺页、缺段异常），由处理器通知操作系统，若有空余空间则将相应的页面或段调入内存，继续执行；   
    另一方面，os将内存中暂时不用的页、段调出保存在外存上以腾出空间。    
* 大的用户空间：内存可以小，硬盘必须足够。提供给用户的虚拟空间=物理内存+硬盘
* 部分交换：swap in/swap out 是对部分虚拟地址空间进行的
* 不连续：物理内存分配的不连续，虚拟空间使用的不连续（内外存）

**具体实现**   
    多采用虚拟页式内存管理，增加了请求调页和页面置换功能    
    只装入部分页面即可启动程序，如果要运行的程序和数据不在内存即页表项invalid，则会抛出异常，向系统发出缺页中断请求，   
    os根据产生异常的地址找到对应在外存中的页面调入，使得继续运行。   

**页表项**
    驻留位： 为1，该页在内存，0，在外存，访问就会缺页中断；   
    保护位： 是否允许某种访问，只读、可读写、可执行；   
    修改位：在内存中是否被修改过，回收物理页面时据此算法决定是不是把内容写会外存；   
    访问位：如果被访问（读、写）设1，用于页面置换算法。不常用的高可能被置换；   

**对缺页中断的理解**   
    1.如果在内存中有空闲的物理空间，则分配一个物理页帧f，然后转4，否则2 
    2.采用某种页面置换算法，选择一个被替换的物理页帧，其对应逻辑页为q，没修改过可直接释放，如果修改位是1，则要写回外存；   
    3.把q的对应页表项驻留位设为0   
    4.把需要访问的页面p装入到物理页面f中
    5.修改p对应页表项，驻留位为1，物理页帧号设置为f   
    6.restart

思路
    将不常用的部分内存块暂存到外村
原理
    装载程序时
        只将当前指令执行需要的部分页面或段装入内存
    指令执行中需要的指令或数据不在内存（缺页）
        处理器通知操作系统将相应的页面或段调入内存
    操作系统将内存中暂时不用的页面或段保存到外村
实现方式
    虚拟页式存储
    虚拟段式存储

基本特征
    不连续性
        物理内存分配非连续
        虚拟地址空间使用非连续
    大用户空间
        提供给用户的虚拟内存可大于实际的物理内存
    部分交换
        虚拟存储只对部分虚拟地址空间进行调入和调出