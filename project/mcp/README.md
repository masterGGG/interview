mcp是一个纯异步网络事件通知，高性能，高可靠，可扩展的网络服务器框架。通用性高，提供了热重启，过载保护，负载监控、带缓冲的socker收发、插件化开发等特性。

我们nosql平台的代理层是基于内部一个高性能的网络通信框架开发的代理服务，并在其上实现了权限校验、数据校验、分片路由与聚合、热key缓存、读写分离，命令禁用，负载统计等特性。我也深度参与了代理服务的开发。实现了pipeline、hashtag特性、流量压缩等特性。

# pipeline实现难点
1. 如何保证有序？
2. 如何保证热升级，减低对业务的影响？
## 如何保证有序？
设计前期，我先调研了一些业内pipeline的实现方式，
> * twitter开源的twme是一个高性能单线程的事件驱动代理服务，它会为每个client连接维护一个接收队列和发送队列，接收到client请求之后，将请求压入接收队列，转发后端处理之后，将请求压入发送队列，后续收到cache应答之后，通过事件机制触发回写逻辑，按接收队列顺序回复保证pipeline实现。
> * 豌豆荚开源的codis也是类似的逻辑，在创建client连接对象时，开启读写两个协程，读协程读取client请求，转发至后端cache处理并将请求消息加入应答队列，后续收到cache应答后，将应答设置为请求的一个成员，并通知写协程轮询应答队列，将应答就绪的请求回复给client，保证请求pipeline。
我们nosql平台为什么不支持pipeline呢，主要是代理服务网络框架内部没有做请求与应答的映射，回写服务只是简单的将client连接应答缓冲区的数据依次回写。同时为了提升并发能力，代理转发服务采用了多进程的架构，进行请求的分发处理，不能保证请求会顺序到达cache，收到的应答大概率会乱序。
设计的核心就是建立请求与应答的映射关系，保证按序回复。参考codis以及twme，对框架进行pipeline适配。设计一个序列号管理器，维护一个序列号资源池，
## 如何保证热升级，减低对业务的影响？